use strum::IntoEnumIterator;

#[derive(Debug, Clone, Copy, strum::EnumIter, PartialEq, Eq, Hash)]
pub enum IOType {
    JOYP,
    SB,
    SC,
    DIV,
    TIMA,
    TMA,
    TAC,
    IF,
    NR10,
    NR11,
    NR12,
    NR13,
    NR14,
    NR21,
    NR22,
    NR23,
    NR24,
    NR30,
    NR31,
    NR32,
    NR33,
    NR34,
    NR41,
    NR42,
    NR43,
    NR44,
    NR50,
    NR51,
    NR52,
    // TODO: Wave is actually 16 bytes long
    WAV,
    LCDC,
    STAT,
    SCY,
    SCX,
    LY,
    LYC,
    DMA,
    BGP,
    OBP0,
    OBP1,
    WY,
    WX,
    SYS,
    SPD,
    VBK,
    HdmaSrcHi,
    HdmaSrcLo,
    HdmaDstHi,
    HdmaDstLo,
    HdmaLen,
    RP,
    BCPS,
    BCPD,
    OCPS,
    OCPD,
    OPRI,
    SVBK,
    PCM12,
    PCM34,
    IE,
}

impl IOType {
    pub fn from_index(index: usize) -> Option<Self> {
        Self::iter().nth(index)
    }

    pub fn from_address(address: u16) -> Option<Self> {
        use IOType::*;
        match address {
            0xFF00 => Some(JOYP),
            0xFF01 => Some(SB),
            0xFF02 => Some(SC),
            0xFF04 => Some(DIV),
            0xFF05 => Some(TIMA),
            0xFF06 => Some(TMA),
            0xFF07 => Some(TAC),
            0xFF0F => Some(IF),
            0xFF10 => Some(NR10),
            0xFF11 => Some(NR11),
            0xFF12 => Some(NR12),
            0xFF13 => Some(NR13),
            0xFF14 => Some(NR14),
            0xFF16 => Some(NR21),
            0xFF17 => Some(NR22),
            0xFF18 => Some(NR23),
            0xFF19 => Some(NR24),
            0xFF1A => Some(NR30),
            0xFF1B => Some(NR31),
            0xFF1C => Some(NR32),
            0xFF1D => Some(NR33),
            0xFF1E => Some(NR34),
            0xFF20 => Some(NR41),
            0xFF21 => Some(NR42),
            0xFF22 => Some(NR43),
            0xFF23 => Some(NR44),
            0xFF24 => Some(NR50),
            0xFF25 => Some(NR51),
            0xFF26 => Some(NR52),
            0xFF30 => Some(WAV),
            0xFF40 => Some(LCDC),
            0xFF41 => Some(STAT),
            0xFF42 => Some(SCY),
            0xFF43 => Some(SCX),
            0xFF44 => Some(LY),
            0xFF45 => Some(LYC),
            0xFF46 => Some(DMA),
            0xFF47 => Some(BGP),
            0xFF48 => Some(OBP0),
            0xFF49 => Some(OBP1),
            0xFF4A => Some(WY),
            0xFF4B => Some(WX),
            0xFF4C => Some(SYS),
            0xFF4D => Some(SPD),
            0xFF4F => Some(VBK),
            0xFF50 => Some(SVBK),
            0xFF51 => Some(HdmaSrcHi),
            0xFF52 => Some(HdmaSrcLo),
            0xFF53 => Some(HdmaDstHi),
            0xFF54 => Some(HdmaDstLo),
            0xFF55 => Some(HdmaLen),
            0xFF56 => Some(RP),
            0xFF68 => Some(BCPS),
            0xFF69 => Some(BCPD),
            0xFF6A => Some(OCPS),
            0xFF6B => Some(OCPD),
            0xFF6C => Some(OPRI),
            0xFF70 => Some(SVBK),
            0xFF76 => Some(PCM12),
            0xFF77 => Some(PCM34),
            0xFFFF => Some(IE),
            _ => None,
        }
    }

    pub fn address(&self) -> u16 {
        use IOType::*;
        match self {
            JOYP => 0xFF00,
            SB => 0xFF01,
            SC => 0xFF02,
            DIV => 0xFF04,
            TIMA => 0xFF05,
            TMA => 0xFF06,
            TAC => 0xFF07,
            IF => 0xFF0F,
            NR10 => 0xFF10,
            NR11 => 0xFF11,
            NR12 => 0xFF12,
            NR13 => 0xFF13,
            NR14 => 0xFF14,
            NR21 => 0xFF16,
            NR22 => 0xFF17,
            NR23 => 0xFF18,
            NR24 => 0xFF19,
            NR30 => 0xFF1A,
            NR31 => 0xFF1B,
            NR32 => 0xFF1C,
            NR33 => 0xFF1D,
            NR34 => 0xFF1E,
            NR41 => 0xFF20,
            NR42 => 0xFF21,
            NR43 => 0xFF22,
            NR44 => 0xFF23,
            NR50 => 0xFF24,
            NR51 => 0xFF25,
            NR52 => 0xFF26,
            WAV => 0xFF30,
            LCDC => 0xFF40,
            STAT => 0xFF41,
            SCY => 0xFF42,
            SCX => 0xFF43,
            LY => 0xFF44,
            LYC => 0xFF45,
            DMA => 0xFF46,
            BGP => 0xFF47,
            OBP0 => 0xFF48,
            OBP1 => 0xFF49,
            WY => 0xFF4A,
            WX => 0xFF4B,
            SYS => 0xFF4C,
            SPD => 0xFF4D,
            VBK => 0xFF4F,
            HdmaSrcHi => 0xFF51,
            HdmaSrcLo => 0xFF52,
            HdmaDstHi => 0xFF53,
            HdmaDstLo => 0xFF54,
            HdmaLen => 0xFF55,
            RP => 0xFF56,
            BCPS => 0xFF68,
            BCPD => 0xFF69,
            OCPS => 0xFF6A,
            OCPD => 0xFF6B,
            OPRI => 0xFF6C,
            SVBK => 0xFF70,
            PCM12 => 0xFF76,
            PCM34 => 0xFF77,
            IE => 0xFFFF,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_io_type_address() {
        for io_type in IOType::iter() {
            assert_eq!(
                io_type,
                IOType::from_address(io_type.address()).unwrap_or_else(|| {
                    panic!(
                        "IOType::from_address({:X}) returned None",
                        io_type.address()
                    )
                })
            );
        }
    }
}
